## 字符串

1. 想清楚步骤，每一步需要做什么
2. 是不是可以写一些循环利用的方法
3. 每个方法，需要传入哪些参数
4. 需要什么循环，满足循环的条件和退出循环的条件
5. 需要返回的值



### 344.  反转字符串

Reverse String

Write a function that reverses a string. The input string is given as an array of characters `s`.

You must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.

```
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
```



**【双指针】**

Time: O(n)

Space: O(1)

```java
class Solution {
    public void reverseString(char[] s) {
        int n = s.length; //直接是数组，用s.length即可
        //如果是String s，则需要用s.length()
        int l = 0, r = n - 1;
        while (l < r){
            char c = s[l];
            s[l] = s[r];
            s[r] = c;
            l++;
            r--;
        }
    }
}
```





### 541. 翻转字符串II

Reverse String II

Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.

If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.

```
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
```

**【双指针】**

Time: O(n)

Space: O(1)

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] arr = s.toCharArray();
        int n = s.length();
        for (int i = 0; i < n; i += 2 * k){
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return String.valueOf(arr);
    }

    public void reverse(char[] arr, int l, int r){
        while (l < r){
            char c = arr[l];
            arr[l] = arr[r];
            arr[r] = c;
            l++;
            r--;
        }
    }
}
```







### 151. 反转一个字符串的word

Reverse Words in a String

Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return *a string of the words in reverse order concatenated by a single space.*

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```



Time: O(n)

Space: O(1)

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);  
        reverse(sb, 0, sb.length() - 1);
        reverseWord(sb);
        return sb.toString();
    }

    // 1. 去除首尾空格和中间多余的空格
    public StringBuilder removeSpace(String s){
        int left = 0, right = s.length() - 1;
        //去除字符串两边的空格，将left和right移动至两边有字符串的位置
        while (left <= right && s.charAt(left) == ' ') left++;  
        while (left <= right && s.charAt(right) == ' ') right--;
        StringBuilder sb = new StringBuilder(); // 创建了一个空的可变字符串对象StringBuilder
        while (left <= right){
            char c = s.charAt(left);
            if (c != ' '){ // 遍历到字母则放入sb中
                sb.append(c);
            // 如果left遇到空格，判断：sb中最后一位不为空，说明前一个字符已经遍历完，就将这个空格放入sb中
            } else if (sb.charAt(sb.length() - 1) != ' ') {
                sb.append(c);
            }
            left++;
        }
        // 返回去除完空格的字符串
        return sb;
    }

    // 2. 双指针翻转去除完空格后的全部字符串
    public void reverse(StringBuilder sb, int left, int right){
        while (left < right){
            char tmp = sb.charAt(left);
            // setCharAt(int index, char c) 表示将指定索引位置index的字符替换为指定的字符c
            // 将sb 中left 位置替换为right; 将right位置替换成tmp(此前存储的left位置的值)
            sb.setCharAt(left++, sb.charAt(right));
            sb.setCharAt(right--, tmp);
        }
    }

    //  翻转StringBuilder中的每个字母
    public void reverseWord(StringBuilder sb){
        int n = sb.length();
        int start = 0, end = 0;
        while (start < n){
            while (end < n && sb.charAt(end) != ' '){ //需要循环
                end++;
            }
            reverse(sb, start, end - 1);
            start = end + 1;
            end++;
        }
    }
}
```



【自带方法】

Time: O(n)

Space: O(n)

```java
class Solution {
    public String reverseWords(String s) {
        // trim()方法用于去除字符串开头和结尾的空格，返回新的字符串对象
        // split()方法用于根据给定的分隔符将字符串拆分成一个字符串数组
        // \s+表示匹配一个或多个空格
        // asList()方法将字符串数组转换为List<String>类型
        // reverse()方法用于将List中的元素顺序反转
        // join()方法用于将List中的元素按照指定的分隔符拼接成一个字符串，返回新的字符串对象。这里是将倒序排列后的单词按照空格拼接成一个新的字符串。
        s = s.trim();
        List<String> wordList = Arrays.asList(s.split("\\s+"));
        Collections.reverse(wordList);
        return String.join(" ", wordList);
    }
}
```



### 459. 重复的子字符串

Repeated Substring Pattern

Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

```
Input: s = "abab"
Output: true
```

【枚举】

Time: O(n平方)

Space: O(1)

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        for (int i = 1; i * 2 <= n; i++){
            if (n % i == 0){
                boolean match = true;
                for (int j = i; j < n; j++){
                    if (s.charAt(j) != s.charAt(j - i)){
                        match = false;
                        break;
                    }
                }
                if (match) return true;
            }
        }
        return false;
    }
}
```



### 424. 替换后的最长重复字符

Longest Repeating Character Replacement

You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return *the length of the longest substring containing the same letter you can get after performing the above operations*.

```
Input: s = "ABAB", k = 2
Output: 4
```

#### 【滑动窗口】

O(N)

O(1)

```java
class Solution {
    public int characterReplacement(String s, int k) {
        if (s == null) return 0; 
        // map 里存储26个字母，每个字母在窗口中出现过的次数
        int[] map = new int[26];
        char[] chars = s.toCharArray(); //将string转换成array用以遍历
        int left = 0;
        int right = 0;
        int max = 0;
        for (right = 0; right < chars.length; right++) {
            // 在ASCII编码中，大写字母'A'的值是65，依次递增到字母'Z'的值为90。
            // 因此，chars[right] - 'A'的结果将'A'到'Z'这26个大写字母转换成了0到25之间的整数。
            int index = chars[right] - 'A';
            map[index]++;
            // max是曾经积累过的窗口里出现相同字母最多的次数
            // 如窗口里是【ABA】，则map里对应0的位置（A）value为2，max为2
            max = Math.max(max, map[index]);
            if (right - left + 1 > max + k) {
                // 如果当前right++ 后的窗口超出目前满足条件的最大窗口max + k
                // 则将窗口中最左边left对应值在map中的数量-1，left右移一格
                // 这里保证了窗口保持在当前最大的范围
                map[chars[left] - 'A']--;
                left++;
            }
        }
        // 遍历完整个chars, left 到 最后一个值之间的距离就是最大的length
        // AABA 最长的范围是4，index计算3-0+1 ，或者length-0
        return chars.length - left;
    }
}
```







### 125. 验证回文字符串

Valid Palindrome

A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` *if it is a **palindrome**, or* `false` *otherwise*.

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

#### 【双指针】

左右指针分别指向字符串的两端；

判断如果不是字母或者数字，左边不是，则左往右移；右边不是则往左移，直到两个指针都遇到数字或者字母；

将两端的字母或者数字进行小写字母转换；若不相等，返回false，若相等，继续比较下一个；

O(N)

O(1)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int n = s.length();
        int left = 0;
        int right = n - 1;
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            if (left < right) {
                if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                    return false;
                }
                left++;
                right--;
            }
        }
        return true;
    }
}
```



### 49. 字母异位词分组

Group Anagrams

Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

#### 【排序map】

O(nk logk) n是遍历字符串的数量，k是最大字符串的长度，需要klogk时间排序；O(1)更新hash表

O(nk) 

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        // 先排序，将排序了的字符串存成key
        // 将后续有与这个key相同的值，存入value中
        // 即相同的key对应的value是一个以排序后等于当前key的list集合
        for (String s : strs) {
            //需要将当前string转化为char[]才能进行排序
            // 然后将char[]排序，再转化成key
            // 取出对应的key的value值，将新值添加进value，存进map
            char[] arr = s.toCharArray(); 
            Arrays.sort(arr);
            String key = new String(arr);
            // 从map中取出对应key的值，用list暂存
            // 如果key对应没有value，则新建一个list，将当前的s存入list
            // 最后将list放入map中
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(s);
            map.put(key, list);
        }
        // 返回一个数组，数组中存的类型是list<String>，值是map.value()；
        return new ArrayList<List<String>>(map.values());
    }
}
```

