# 复杂度分析



## 时间复杂度

在时间频度`T(n)`中，n又代表着问题的规模，当n不断变化时，`T(n)`也会不断地随之变化。为了了解这个变化的规律，**时间复杂度**这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度`T(n)`。如果有某个辅助函数`f(n)`，当趋于无穷大的时候，`T(n)/f(n)`的极限值是不为零的某个常数，那么`f(n)`是`T(n)`的同数量级函数，记作`T(n)=O(f(n))`，被称为**算法的渐进时间复杂度**，又简称为**时间复杂度**。

**用O(n)来体现算法时间复杂度的记法被称作大O表示法**

`T(n) = O(f(n))`

**大小比较：**O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

### O(1) 常数阶

0(1) 复杂度算法也称之为常数阶算法。这里的 `1` 是用来代指常量，也就是说这个算法的效率是固定的，无论你的数据量如何变化，效率都一样，这种复杂度也是最优的一种算法。

```java
public static void print(int n){
    int a = 1;
    int b = 2;
    int c = 3;
    int sum = a + b + c;
    System.out.println(sum);
}
```

### O(logn) 对数阶

二分查找，二叉树之类的问题中会见到比较多的对数阶复杂度

```jav
public static void print2(int n){
    int i=1;
    while (i <= n) {
        i = i * 2;
    }
}
```

`while` 循环中到底循环了多少次，我们观察这个循环，发现 `i` 并不是逐一递增，而是不断的翻倍：`1->2->4->8->16->32->64` 一直到等于 `n` 为止才会结束，所以我们得到了这样的一个公式：`2^x=n`

### O(n) 线性阶

```java
public static void print1(int n){
    int a = 0;
    for (int i=0;i<n;i++){
        System.out.println(i);
    }
}
```

### O(nlogn) 线性对数阶

只需要在对数阶的算法中再嵌一层循环就是线性对数阶

```java
for (int j=1;j<=n;j++){
    int i=1;
    while (i <= n) {
        i = i * 2;
    }
}
```



### O(n²) 平方阶

双层循环就是平方阶，同理，三次循环就是立方阶，`k` 次循环就是 `k` 次方阶



### 组合式复杂度分析

#### 取最大复杂度

```java
public static void print1(int n){
    for (int i=0;i<1000;i++){
        System.out.println(i);
    }
    for (int j=0;j<n;j++){
        System.out.println(j);
    }

    for (int p=0;p<n;p++){
        for (int q=0;q<n;q++){
            System.out.println(p+q);
        }
    }
}
```

有三个循环，第一个是一个常量，那么根据前面的结论，不论这个常量是多大，都属于常量级，所以第一个循环中的复杂度为 `O(1)`，第二个和第三个循环我们前面也分析过，复杂度分别为 `O(n)` 和 `O(n²)`

这三个复杂度可以很明显得到的大小关系为：`O(1)<O(n)<O(n²)`

像这种在同一个算法中有明确大小关系的，我们就可以直接取最大值作为这个算法的复杂度，所以这个例子中算法的复杂度就是 `O(n²)`。

#### 取多个复杂度之和

```java
public static void print2(int m,int n){
    for (int i=0;i<1000;i++){
        System.out.println(i);
    }
    for (int j=0;j<m;j++){
        System.out.println(j);
    }
    for (int k=0;k<n;k++){
        System.out.println(k);
    }
}
```

三段循环分别分析可以分别得到如下复度：`O(1)`，`O(m)`，`O(n)`。

这时候我们只能知道 `O(1)` 最小可以忽略，但是后面两个无法却无法确定大小，所以这时候我们需要取两段循环复杂度之和来作为算法的复杂度，所以可以得到这个例子的算法复杂度为：`O(m+n)`。



### 逻辑计算

#### 一层循环

- 解题思路

  1. 列出循环次数 **t**， 及每次循环 **i** 的变化值
  2. 找到 **t 与 i 的关系**
  3. 确定**循环停止**条件
  4. 连立两式，解方程
  5. 写结果 （去除系数）

- 例1：

  ```java
  i = n * n;
  while (i != 1){
    i = i / 2;
  }
  ```

- 例2:

  ```java
  x = 0;
  while (n >= (x + 1) * (x + 1)) {
    x = x + 1;
  }
  ```

- 解：

  <img src="[/Users/sugar/Documents/leetcode/pic/一层循环.jpeg](https://github.com/xiaoshuzhao/leetcode-java/blob/main/pictures/%E4%B8%80%E5%B1%82%E5%BE%AA%E7%8E%AF.jpeg)" alt="一层循环" style="zoom:33%;" />

#### 两层循环

- 解题思路

  1. 列出外层循环中 i 的变化值
  2. 列出内层语句的执行次数
  3. 求和，写结果

- 例1:

  ```java
  int m = 0, i, j;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= 2 * i; j++) {
      m++;
    }
  }
  ```

- 例2:

  ```java
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      a[i][j] = 0;
    }
  }
  ```

- 解

  <img src="/Users/sugar/Documents/leetcode/pic/二层循环.jpeg" alt="二层循环" style="zoom:33%;" />

- 例3: 

  ```java
  count = 0;
  for (k = 1; k <= n; k *= 2) {
    for (j = 0; j <= n; j++) {
      count++;
    }
  }
  // k以指数级由1增长至n，个数约为log₂n
  // 内层语句每轮循环执行次数均为n
  // 相乘，立即推T=O(nlog₂n)
  ```

  

#### 多层循环

- 解题思路（2种方法）
  1. 抽象为计算三维体积
  2. 列式求和





## 空间复杂度

渐进空间复杂度，用来表示算法的存储空间与数据规模之间的增长关系。

主要就看我们在一个算法当中到底有没有使用到了额外的空间来进行存储数据，然后判断这个额外空间的大小会不会随着 `n` 的变化而变化，从而得到空间复杂度。

```java
public static void init(int n){
    int a = 0;
    int arr[] = new int[n];
    for (int i=0;i<n;i++){
        arr[i]=n;
    }
}
```

一开始定义了一个变量，这里需要空间，但是这是一个常量级的（不随 `n` 的变化而变化）;

然后再定义了一个数组，数组的长度为 `n`，这里数组也需要占用空间，而且数组的空间是随着 `n` 的变化而变化的，其余代码没有占用额外空间；

所以我们就可以认为上面示例中的空间复杂度为 `O(n)`。

1. 有限个数（常量）的变量，空间复杂度为 `O(1)`。

2. 一维数组，队列或者链表等，那么空间复杂度为 `O(n)`。

3. 二维数组，那么空间复杂度为 `O(n²)`

   算法中定义了一个二维列表集合，并且集合的长和宽都和输入规模n成正比，空间复杂度记为O(nn)/O（n*m)

4. 递归空间
   递归过程就是一个进栈和出栈的过程，当进入一个新函数时，进行入栈操作，把调用的函数和参数信息压入栈中；当函数返回时，执行出栈。
   递归的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)












